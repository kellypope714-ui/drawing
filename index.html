<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Graphite Drawing Reference App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #2c3e50, #34495e);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 30px;
            padding: 30px;
        }
        
        .workspace {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .upload-section {
            background: #f8f9fa;
            border: 3px dashed #dee2e6;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .upload-section:hover {
            border-color: #007bff;
            background: #e3f2fd;
        }
        
        .upload-section input[type="file"] {
            display: none;
        }
        
        .upload-btn {
            background: linear-gradient(135deg, #007bff, #0056b3);
            color: white;
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 1.1rem;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s ease;
        }
        
        .upload-btn:hover {
            transform: translateY(-2px);
        }
        
        .image-container {
            position: relative;
            max-width: 100%;
            margin: 20px 0;
        }
        
        .reference-image {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
            cursor: crosshair;
        }
        
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
        }
        
        .control-btn {
            background: #6c757d;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .control-btn:hover {
            background: #5a6268;
            transform: translateY(-1px);
        }
        
        .control-btn.active {
            background: #28a745;
        }
        
        .sidebar {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 25px;
            height: fit-content;
        }
        
        .pencil-info {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .pencil-grade {
            font-size: 1.5rem;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
        }
        
        .pencil-description {
            color: #6c757d;
            line-height: 1.6;
        }
        
        .histogram {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .histogram h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .histogram-bars {
            display: flex;
            align-items: end;
            height: 100px;
            gap: 1px;
            background: #f8f9fa;
            border-radius: 5px;
            padding: 5px;
        }
        
        .histogram-bar {
            background: linear-gradient(to top, #007bff, #0056b3);
            border-radius: 2px;
            flex: 1;
            min-height: 2px;
        }
        
        .tips-section {
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .tips-section h3 {
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .tip-item {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            border-left: 4px solid #007bff;
        }
        
        .pixel-info {
            position: fixed;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9rem;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        
        .pencil-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        .pencil-grade-overlay {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: bold;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }
        
        .pencil-scale {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 15px 0;
        }
        
        .pencil-grade-item {
            background: #e9ecef;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .canvas-container {
            position: relative;
            display: none;
        }
        
        @media (max-width: 1024px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎨 Graphite Drawing Reference App</h1>
            <p>Upload your reference photo and get detailed pencil guidance for realistic drawings</p>
        </div>
        
        <div class="main-content">
            <div class="workspace">
                <div class="upload-section" id="uploadSection">
                    <h3>📸 Upload Your Reference Photo</h3>
                    <p>Supports color and grayscale images</p>
                    <input type="file" id="imageInput" accept="image/*">
                    <button class="upload-btn" onclick="document.getElementById('imageInput').click()">
                        Choose Reference
                    </button>
                    <button class="upload-btn" onclick="convertToGrayscale()">
                        Convert to Grayscale
                    </button>
                </div>
                
                <div class="upload-section" id="drawingUploadSection" style="display: none;">
                    <h3>🎨 Upload Your Drawing</h3>
                    <p>Compare your drawing to the reference for improvement tips</p>
                    <input type="file" id="drawingInput" accept="image/*">
                    <button class="upload-btn" onclick="document.getElementById('drawingInput').click()">
                        Choose Drawing
                    </button>
                    <button class="upload-btn" onclick="compareDrawings()">
                        Compare & Analyze
                    </button>
                </div>
                
                <div class="controls">
                    <button class="control-btn" onclick="resetToOriginal()">Reset to Original</button>
                    <button class="control-btn" onclick="toggleGrid()">Toggle Grid</button>
                    <select id="gridSize" onchange="updateGridSize()" style="padding: 10px; border-radius: 8px; margin: 0 5px;">
                        <option value="20">Small Grid (20px)</option>
                        <option value="40">Medium Grid (40px)</option>
                        <option value="60">Large Grid (60px)</option>
                        <option value="80">Extra Large Grid (80px)</option>
                    </select>
                    <button class="control-btn" onclick="togglePencilOverlay()">Show Pencil Grades</button>
                    <button class="control-btn" onclick="showHighlights()">Show Highlights</button>
                    <button class="control-btn" onclick="showMidtones()">Show Midtones</button>
                    <button class="control-btn" onclick="showShadows()">Show Shadows</button>
                    <button class="control-btn" onclick="createOutline()">Create Outline</button>
                    <button class="control-btn" onclick="analyzeContrast()">Analyze Contrast</button>
                </div>
                
                <div class="image-container" id="imageContainer" style="display: none;">
                    <img id="referenceImage" class="reference-image" alt="Reference Image">
                    <svg class="grid-overlay" id="gridOverlay" style="display: none;"></svg>
                    <div class="pencil-overlay" id="pencilOverlay" style="display: none;"></div>
                </div>
                
                <div class="image-container" id="drawingContainer" style="display: none;">
                    <h3 style="color: #2c3e50; margin-bottom: 15px;">📝 Your Drawing</h3>
                    <img id="drawingImage" class="reference-image" alt="Your Drawing">
                </div>
                
                <div class="canvas-container" id="canvasContainer">
                    <canvas id="imageCanvas" style="display: none;"></canvas>
                </div>
            </div>
            
            <div class="sidebar">
                <div class="pencil-info" id="pencilInfo">
                    <div class="pencil-grade">Select a pixel</div>
                    <div class="pencil-description">Hover over your reference image to see pencil recommendations</div>
                    
                    <div class="pencil-scale">
                        <div class="pencil-grade-item" style="background: #1a1a1a; color: white;">12B</div>
                        <div class="pencil-grade-item" style="background: #2a2a2a; color: white;">11B</div>
                        <div class="pencil-grade-item" style="background: #3a3a3a; color: white;">10B</div>
                        <div class="pencil-grade-item" style="background: #4a4a4a; color: white;">9B</div>
                        <div class="pencil-grade-item" style="background: #5a5a5a; color: white;">8B</div>
                        <div class="pencil-grade-item" style="background: #6a6a6a; color: white;">7B</div>
                        <div class="pencil-grade-item" style="background: #7a7a7a; color: white;">6B</div>
                        <div class="pencil-grade-item" style="background: #8a8a8a;">5B</div>
                        <div class="pencil-grade-item" style="background: #9a9a9a;">4B</div>
                        <div class="pencil-grade-item" style="background: #aaa;">3B</div>
                        <div class="pencil-grade-item" style="background: #bbb;">2B</div>
                        <div class="pencil-grade-item" style="background: #ccc;">B</div>
                        <div class="pencil-grade-item" style="background: #ddd;">HB</div>
                        <div class="pencil-grade-item" style="background: #eee;">F</div>
                        <div class="pencil-grade-item" style="background: #f0f0f0;">H</div>
                        <div class="pencil-grade-item" style="background: #f2f2f2;">2H</div>
                        <div class="pencil-grade-item" style="background: #f4f4f4;">3H</div>
                        <div class="pencil-grade-item" style="background: #f6f6f6;">4H</div>
                        <div class="pencil-grade-item" style="background: #f8f8f8;">5H</div>
                        <div class="pencil-grade-item" style="background: #fafafa;">6H</div>
                        <div class="pencil-grade-item" style="background: #fcfcfc;">7H</div>
                        <div class="pencil-grade-item" style="background: #fdfdfd;">8H</div>
                        <div class="pencil-grade-item" style="background: #fefefe;">9H</div>
                        <div class="pencil-grade-item" style="background: #ffffff; border: 1px solid #ddd;">10H</div>
                    </div>
                </div>
                
                <div class="histogram">
                    <h3>📊 Drawing Histogram</h3>
                    <div class="histogram-container" style="position: relative; height: 160px; margin: 20px 0; background: #f8f9fa; border-radius: 10px; padding: 15px;">
                        <!-- Traditional histogram bars -->
                        <div class="histogram-bars" id="histogramBars" style="display: flex; align-items: end; height: 100px; gap: 1px; margin-bottom: 10px;">
                            <!-- Bars will be generated here -->
                        </div>
                        
                        <!-- Gradient bar showing black to white -->
                        <div class="gradient-bar" style="height: 20px; background: linear-gradient(to right, #000, #fff); border-radius: 4px; position: relative; margin-bottom: 10px;">
                            <!-- Black point slider -->
                            <div id="blackSlider" class="point-slider" style="position: absolute; left: 0px; top: -5px; cursor: grab;">
                                <div class="slider-triangle" style="width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 15px solid #000; margin-left: -8px;"></div>
                                <div class="slider-label" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: #000; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.7rem; white-space: nowrap;">
                                    Black: <span id="blackValue">0</span>
                                </div>
                            </div>
                            
                            <!-- White point slider -->
                            <div id="whiteSlider" class="point-slider" style="position: absolute; right: 0px; top: -5px; cursor: grab;">
                                <div class="slider-triangle" style="width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-bottom: 15px solid #fff; border: 1px solid #333; margin-left: -8px;"></div>
                                <div class="slider-label" style="position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: #fff; color: #333; padding: 2px 6px; border-radius: 3px; font-size: 0.7rem; white-space: nowrap; border: 1px solid #ccc;">
                                    White: <span id="whiteValue">255</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="control-btn" onclick="resetLevels()" style="flex: 1; font-size: 0.8rem; padding: 8px;">
                            Reset
                        </button>
                        <button class="control-btn" onclick="applyLevels()" style="flex: 1; font-size: 0.8rem; padding: 8px; background: #28a745;">
                            Apply
                        </button>
                    </div>
                </div>
                
                <div class="tips-section">
                    <h3>📝 Layering Guide</h3>
                    <div id="layeringGuide">
                        <div class="tip-item">
                            <strong>Layer 1 - Foundation (4H-2H):</strong> Light construction lines and basic shapes. Use minimal pressure.
                        </div>
                        <div class="tip-item">
                            <strong>Layer 2 - Base Tones (HB-2B):</strong> Establish basic light and shadow areas. Blend with tissue paper.
                        </div>
                        <div class="tip-item">
                            <strong>Layer 3 - Mid Shadows (3B-5B):</strong> Build up shadow depth. Use blending stump for smooth transitions.
                        </div>
                        <div class="tip-item">
                            <strong>Layer 4 - Deep Shadows (6B-9B):</strong> Add darkest areas. Use tortillion for precise blending.
                        </div>
                        <div class="tip-item">
                            <strong>Layer 5 - Final Details (10B-12B):</strong> Deepest blacks and final contrast. Minimal blending needed.
                        </div>
                    </div>
                </div>
                
                <div class="tips-section">
                    <h3>💡 Drawing Tips</h3>
                    <div id="tipsContainer">
                        <div class="tip-item">
                            <strong>Getting Started:</strong> Begin with light strokes using H pencils (2H-4H) for initial sketching and guidelines.
                        </div>
                        <div class="tip-item">
                            <strong>Building Layers:</strong> Gradually build up darker tones using B pencils, starting with lighter grades (2B, 4B) before moving to darker ones.
                        </div>
                        <div class="tip-item">
                            <strong>Blending Tools:</strong> Use tissue paper for large areas, blending stumps for medium details, and tortillions for fine work.
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="pixel-info" id="pixelInfo"></div>
    
    <script>
        const pencilGrades = [
            { name: '12B', value: 0, description: 'Darkest blacks and deepest shadows. Use for the absolute darkest areas.' },
            { name: '11B', value: 10, description: 'Very dark shadows. Blend with 12B for smooth transitions.' },
            { name: '10B', value: 20, description: 'Deep shadows. Great for creating dramatic contrast.' },
            { name: '9B', value: 30, description: 'Dark shadows. Use blending stump for smooth application.' },
            { name: '8B', value: 40, description: 'Medium-dark shadows. Layer over lighter grades.' },
            { name: '7B', value: 50, description: 'Dark midtones. Blend with tissue paper for large areas.' },
            { name: '6B', value: 60, description: 'Medium-dark tones. Good for building up shadows gradually.' },
            { name: '5B', value: 70, description: 'Dark midtones. Use circular motions for even coverage.' },
            { name: '4B', value: 80, description: 'Medium tones. Great for general shading work.' },
            { name: '3B', value: 90, description: 'Medium tones. Use for initial shadow mapping.' },
            { name: '2B', value: 100, description: 'Light-medium tones. Good for subtle shading.' },
            { name: 'B', value: 110, description: 'Light tones. Use for gentle shadows and transitions.' },
            { name: 'HB', value: 120, description: 'Neutral tone. Good for general sketching and outlines.' },
            { name: 'F', value: 130, description: 'Light tones. Use for fine details and light shading.' },
            { name: 'H', value: 140, description: 'Light tones. Good for initial construction lines.' },
            { name: '2H', value: 150, description: 'Very light tones. Use for guidelines and light details.' },
            { name: '3H', value: 160, description: 'Very light tones. Good for preliminary sketching.' },
            { name: '4H', value: 170, description: 'Extremely light. Use for initial layout and guidelines.' },
            { name: '5H', value: 180, description: 'Barely visible marks. For construction and measuring.' },
            { name: '6H', value: 190, description: 'Very light guidelines. Use minimal pressure.' },
            { name: '7H', value: 200, description: 'Extremely light. For initial proportional guidelines.' },
            { name: '8H', value: 210, description: 'Nearly invisible. For construction purposes only.' },
            { name: '9H', value: 220, description: 'Invisible unless pressed hard. For layout work.' },
            { name: '10H', value: 230, description: 'Leave as white paper. Use kneaded eraser to lift graphite.' }
        ];
        
        let currentImage = null;
        let originalImageSrc = null;
        let canvas = null;
        let ctx = null;
        let imageData = null;
        let gridVisible = false;
        let pencilOverlayVisible = false;
        let currentDrawing = null;
        let drawingCanvas = null;
        let drawingCtx = null;
        let drawingImageData = null;
        let currentGridSize = 20;
        let originalImageData = null;
        let currentBlackPoint = 0;
        let currentWhitePoint = 255;
        
        document.getElementById('imageInput').addEventListener('change', handleImageUpload);
        document.getElementById('drawingInput').addEventListener('change', handleDrawingUpload);
        
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = document.getElementById('referenceImage');
                img.src = e.target.result;
                originalImageSrc = e.target.result; // Store original
                img.onload = function() {
                    currentImage = img;
                    setupCanvas();
                    document.getElementById('imageContainer').style.display = 'block';
                    document.getElementById('drawingUploadSection').style.display = 'block';
                    setupImageInteraction();
                };
            };
            reader.readAsDataURL(file);
        }
        
        function handleDrawingUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = document.getElementById('drawingImage');
                img.src = e.target.result;
                img.onload = function() {
                    currentDrawing = img;
                    setupDrawingCanvas();
                    document.getElementById('drawingContainer').style.display = 'block';
                    generateDrawingHistogram();
                };
            };
            reader.readAsDataURL(file);
        }
        
        function setupDrawingCanvas() {
            if (!drawingCanvas) {
                drawingCanvas = document.createElement('canvas');
                drawingCtx = drawingCanvas.getContext('2d');
            }
            
            const img = currentDrawing;
            drawingCanvas.width = img.naturalWidth;
            drawingCanvas.height = img.naturalHeight;
            
            drawingCtx.drawImage(img, 0, 0);
            drawingImageData = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
        }
        
        function setupCanvas() {
            canvas = document.getElementById('imageCanvas');
            ctx = canvas.getContext('2d');
            
            const img = currentImage;
            canvas.width = img.naturalWidth;
            canvas.height = img.naturalHeight;
            
            ctx.drawImage(img, 0, 0);
            imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            originalImageData = ctx.getImageData(0, 0, canvas.width, canvas.height); // Store original for tonal adjustments
        }
        
        function setupImageInteraction() {
            const img = document.getElementById('referenceImage');
            const pixelInfo = document.getElementById('pixelInfo');
            
            img.addEventListener('mousemove', function(e) {
                if (!imageData) return;
                
                const rect = img.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const x = Math.floor((e.clientX - rect.left) * scaleX);
                const y = Math.floor((e.clientY - rect.top) * scaleY);
                
                if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                    const pixelIndex = (y * canvas.width + x) * 4;
                    const r = imageData.data[pixelIndex];
                    const g = imageData.data[pixelIndex + 1];
                    const b = imageData.data[pixelIndex + 2];
                    
                    const grayscale = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                    const pencil = getPencilForValue(grayscale);
                    
                    updatePencilInfo(pencil, grayscale);
                    
                    pixelInfo.style.display = 'block';
                    pixelInfo.style.left = e.clientX + 10 + 'px';
                    pixelInfo.style.top = e.clientY - 10 + 'px';
                    pixelInfo.innerHTML = `${pencil.name} - ${grayscale}/255`;
                }
            });
            
            img.addEventListener('mouseleave', function() {
                pixelInfo.style.display = 'none';
            });
        }
        
        function getPencilForValue(grayscale) {
            const normalizedValue = (255 - grayscale) / 255 * 240;
            
            for (let i = 0; i < pencilGrades.length - 1; i++) {
                if (normalizedValue >= pencilGrades[i].value && normalizedValue < pencilGrades[i + 1].value) {
                    return pencilGrades[i];
                }
            }
            return pencilGrades[pencilGrades.length - 1];
        }
        
        function updatePencilInfo(pencil, grayscaleValue) {
            const pencilInfo = document.getElementById('pencilInfo');
            const blendingTip = getBlendingTip(pencil.name);
            const eraserTip = getEraserTip(grayscaleValue);
            
            pencilInfo.innerHTML = `
                <div class="pencil-grade">${pencil.name}</div>
                <div class="pencil-description">
                    <strong>Technique:</strong> ${pencil.description}<br><br>
                    <strong>Blending:</strong> ${blendingTip}<br><br>
                    <strong>Eraser Technique:</strong> ${eraserTip}
                </div>
            `;
        }
        
        function getBlendingTip(grade) {
            const bGrades = ['12B', '11B', '10B', '9B', '8B', '7B', '6B'];
            const mediumGrades = ['5B', '4B', '3B', '2B', 'B'];
            const lightGrades = ['HB', 'F', 'H', '2H', '3H', '4H', '5H', '6H', '7H', '8H', '9H', '10H'];
            
            if (bGrades.includes(grade)) {
                return 'Use blending stump or tortillion for smooth, controlled blending. Work in circular motions.';
            } else if (mediumGrades.includes(grade)) {
                return 'Tissue paper wrapped around finger works well for large areas. Blending stump for details.';
            } else {
                return 'Light blending with tissue paper. Use tiny makeup brush for very fine details.';
            }
        }
        
        function getEraserTip(grayscaleValue) {
            if (grayscaleValue > 200) {
                return 'Use kneaded eraser to lift graphite and create highlights. Dab gently, don\'t rub.';
            } else if (grayscaleValue > 100) {
                return 'Small electric eraser for precise highlight details. Use light pressure.';
            } else {
                return 'Kneaded eraser shaped to a point for subtle highlight adjustments in dark areas.';
            }
        }
        
        function convertToGrayscale() {
            if (!currentImage) return;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCanvas.width = currentImage.naturalWidth;
            tempCanvas.height = currentImage.naturalHeight;
            
            tempCtx.drawImage(currentImage, 0, 0);
            const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = Math.round(
                    0.299 * imageData.data[i] +
                    0.587 * imageData.data[i + 1] +
                    0.114 * imageData.data[i + 2]
                );
                imageData.data[i] = gray;
                imageData.data[i + 1] = gray;
                imageData.data[i + 2] = gray;
            }
            
            tempCtx.putImageData(imageData, 0, 0);
            currentImage.src = tempCanvas.toDataURL();
            setupCanvas();
            generateHistogram();
        }
        
        function generateHistogram() {
            if (!imageData) return;
            
            const histogram = new Array(256).fill(0);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = Math.round(
                    0.299 * imageData.data[i] +
                    0.587 * imageData.data[i + 1] +
                    0.114 * imageData.data[i + 2]
                );
                histogram[gray]++;
            }
            
            drawHistogramBars(histogram);
            setupLevelSliders();
        }
        
        function generateDrawingHistogram() {
            if (!drawingImageData) return;
            
            const histogram = new Array(256).fill(0);
            
            for (let i = 0; i < drawingImageData.data.length; i += 4) {
                const gray = Math.round(
                    0.299 * drawingImageData.data[i] +
                    0.587 * drawingImageData.data[i + 1] +
                    0.114 * drawingImageData.data[i + 2]
                );
                histogram[gray]++;
            }
            
            drawHistogramBars(histogram);
            setupLevelSliders();
        }
        
        function drawHistogramBars(histogram) {
            const histogramBars = document.getElementById('histogramBars');
            histogramBars.innerHTML = '';
            
            const maxCount = Math.max(...histogram);
            
            // Create curved histogram using SVG for smooth normal curve appearance
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.cssText = `
                width: 100%;
                height: 100px;
                background: #f8f9fa;
                border-radius: 5px;
            `;
            
            // Create smooth curve path
            let pathData = 'M 0 100';
            const barWidth = 100 / 256; // Percentage width for each bar
            
            for (let i = 0; i < 256; i++) {
                const height = maxCount > 0 ? (histogram[i] / maxCount) * 95 : 0;
                const x = (i / 256) * 100;
                const y = 100 - height;
                
                if (i === 0) {
                    pathData += ` L ${x} ${y}`;
                } else {
                    // Create smooth curve using quadratic bezier curves
                    const prevX = ((i - 1) / 256) * 100;
                    const prevHeight = maxCount > 0 ? (histogram[i - 1] / maxCount) * 95 : 0;
                    const prevY = 100 - prevHeight;
                    
                    const controlX = (prevX + x) / 2;
                    const controlY = (prevY + y) / 2;
                    
                    pathData += ` Q ${controlX} ${controlY} ${x} ${y}`;
                }
            }
            
            pathData += ' L 100 100 Z';
            
            // Create the curve path
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('fill', 'url(#histogramGradient)');
            path.setAttribute('stroke', '#007bff');
            path.setAttribute('stroke-width', '2');
            
            // Create gradient definition
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient.setAttribute('id', 'histogramGradient');
            gradient.setAttribute('x1', '0%');
            gradient.setAttribute('y1', '100%');
            gradient.setAttribute('x2', '0%');
            gradient.setAttribute('y2', '0%');
            
            const stop1 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop1.setAttribute('offset', '0%');
            stop1.setAttribute('stop-color', '#007bff');
            stop1.setAttribute('stop-opacity', '0.8');
            
            const stop2 = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
            stop2.setAttribute('offset', '100%');
            stop2.setAttribute('stop-color', '#0056b3');
            stop2.setAttribute('stop-opacity', '0.3');
            
            gradient.appendChild(stop1);
            gradient.appendChild(stop2);
            defs.appendChild(gradient);
            svg.appendChild(defs);
            svg.appendChild(path);
            
            // Add grid lines for reference
            for (let i = 0; i <= 10; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', '0');
                line.setAttribute('y1', (i * 10).toString());
                line.setAttribute('x2', '100');
                line.setAttribute('y2', (i * 10).toString());
                line.setAttribute('stroke', '#dee2e6');
                line.setAttribute('stroke-width', '0.5');
                line.setAttribute('opacity', '0.5');
                svg.appendChild(line);
            }
            
            histogramBars.appendChild(svg);
        }
        
        function setupLevelSliders() {
            const blackSlider = document.getElementById('blackSlider');
            const whiteSlider = document.getElementById('whiteSlider');
            const gradientBar = blackSlider.parentElement;
            
            let isDragging = null;
            let startX = 0;
            let startLeft = 0;
            
            function startDrag(slider, e) {
                isDragging = slider;
                startX = e.clientX || e.touches[0].clientX;
                const rect = gradientBar.getBoundingClientRect();
                
                if (slider === blackSlider) {
                    startLeft = parseInt(slider.style.left) || 0;
                } else {
                    startLeft = parseInt(slider.style.right) || 0;
                }
                
                slider.style.cursor = 'grabbing';
                e.preventDefault();
            }
            
            function drag(e) {
                if (!isDragging) return;
                
                const currentX = e.clientX || e.touches[0].clientX;
                const deltaX = currentX - startX;
                const rect = gradientBar.getBoundingClientRect();
                const barWidth = rect.width;
                
                if (isDragging === blackSlider) {
                    let newLeft = startLeft + deltaX;
                    newLeft = Math.max(0, Math.min(newLeft, barWidth - 20)); // Don't overlap with white slider
                    
                    // Get white slider position to prevent overlap
                    const whiteRight = parseInt(whiteSlider.style.right) || 0;
                    const whiteLeft = barWidth - whiteRight;
                    newLeft = Math.min(newLeft, whiteLeft - 20);
                    
                    blackSlider.style.left = newLeft + 'px';
                } else {
                    let newRight = startLeft - deltaX;
                    newRight = Math.max(0, Math.min(newRight, barWidth - 20)); // Don't overlap with black slider
                    
                    // Get black slider position to prevent overlap
                    const blackLeft = parseInt(blackSlider.style.left) || 0;
                    const whiteLeft = barWidth - newRight;
                    if (whiteLeft <= blackLeft + 20) {
                        newRight = barWidth - blackLeft - 20;
                    }
                    
                    whiteSlider.style.right = newRight + 'px';
                }
                
                updateLevelValues();
                e.preventDefault();
            }
            
            function stopDrag() {
                if (isDragging) {
                    isDragging.style.cursor = 'grab';
                    isDragging = null;
                }
            }
            
            // Mouse events
            blackSlider.addEventListener('mousedown', (e) => startDrag(blackSlider, e));
            whiteSlider.addEventListener('mousedown', (e) => startDrag(whiteSlider, e));
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch events
            blackSlider.addEventListener('touchstart', (e) => startDrag(blackSlider, e));
            whiteSlider.addEventListener('touchstart', (e) => startDrag(whiteSlider, e));
            document.addEventListener('touchmove', drag);
            document.addEventListener('touchend', stopDrag);
        }
        
        function updateLevelValues() {
            const blackSlider = document.getElementById('blackSlider');
            const whiteSlider = document.getElementById('whiteSlider');
            const gradientBar = blackSlider.parentElement;
            const rect = gradientBar.getBoundingClientRect();
            const barWidth = rect.width;
            
            const blackLeft = parseInt(blackSlider.style.left) || 0;
            const whiteRight = parseInt(whiteSlider.style.right) || 0;
            
            // Convert positions to 0-255 values
            currentBlackPoint = Math.round((blackLeft / barWidth) * 255);
            currentWhitePoint = Math.round(255 - (whiteRight / barWidth) * 255);
            
            // Update display values
            document.getElementById('blackValue').textContent = currentBlackPoint;
            document.getElementById('whiteValue').textContent = currentWhitePoint;
            
            // Apply real-time preview
            applyLevelAdjustments(true);
        }
        
        function toggleGrid() {
            gridVisible = !gridVisible;
            const gridOverlay = document.getElementById('gridOverlay');
            
            if (gridVisible) {
                gridOverlay.style.display = 'block';
                createGrid();
            } else {
                gridOverlay.style.display = 'none';
            }
        }
        
        function togglePencilOverlay() {
            pencilOverlayVisible = !pencilOverlayVisible;
            const pencilOverlay = document.getElementById('pencilOverlay');
            
            if (pencilOverlayVisible) {
                pencilOverlay.style.display = 'block';
                createPencilOverlay();
            } else {
                pencilOverlay.style.display = 'none';
            }
        }
        
        function createPencilOverlay() {
            if (!imageData) return;
            
            const pencilOverlay = document.getElementById('pencilOverlay');
            const img = document.getElementById('referenceImage');
            
            pencilOverlay.innerHTML = '';
            
            // Get current image dimensions
            const rect = img.getBoundingClientRect();
            
            // Use current grid size directly for spacing
            const stepSize = currentGridSize;
            const stepsX = Math.floor(rect.width / stepSize);
            const stepsY = Math.floor(rect.height / stepSize);
            
            for (let gridY = 0; gridY < stepsY; gridY++) {
                for (let gridX = 0; gridX < stepsX; gridX++) {
                    // Calculate canvas coordinates
                    const canvasX = Math.floor((gridX * stepSize / rect.width) * canvas.width);
                    const canvasY = Math.floor((gridY * stepSize / rect.height) * canvas.height);
                    
                    if (canvasX < canvas.width && canvasY < canvas.height) {
                        const pixelIndex = (canvasY * canvas.width + canvasX) * 4;
                        const r = imageData.data[pixelIndex];
                        const g = imageData.data[pixelIndex + 1];
                        const b = imageData.data[pixelIndex + 2];
                        
                        const grayscale = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                        const pencil = getPencilForValue(grayscale);
                        
                        const gradeElement = document.createElement('div');
                        gradeElement.className = 'pencil-grade-overlay';
                        gradeElement.textContent = pencil.name;
                        
                        // Position at grid intersections
                        gradeElement.style.left = (gridX * stepSize + stepSize/2) + 'px';
                        gradeElement.style.top = (gridY * stepSize + stepSize/2) + 'px';
                        
                        pencilOverlay.appendChild(gradeElement);
                    }
                }
            }
        }
        
        function resetToOriginal() {
            if (!originalImageSrc) {
                alert('No original image to reset to. Please upload an image first.');
                return;
            }
            
            const img = document.getElementById('referenceImage');
            img.src = originalImageSrc;
            img.onload = function() {
                currentImage = img;
                setupCanvas();
                generateHistogram();
                
                // Hide overlays
                document.getElementById('gridOverlay').style.display = 'none';
                document.getElementById('pencilOverlay').style.display = 'none';
                gridVisible = false;
                pencilOverlayVisible = false;
                
                // Remove comparison legend if present
                const existingLegend = document.getElementById('comparisonLegend');
                if (existingLegend) {
                    existingLegend.remove();
                }
            };
        }
        
        function updateGridSize() {
            currentGridSize = parseInt(document.getElementById('gridSize').value);
            if (gridVisible) {
                createGrid();
            }
            if (pencilOverlayVisible) {
                createPencilOverlay();
            }
        }
        
        function createGrid() {
            const gridOverlay = document.getElementById('gridOverlay');
            const img = document.getElementById('referenceImage');
            
            gridOverlay.innerHTML = '';
            
            const rect = img.getBoundingClientRect();
            const gridSize = currentGridSize;
            
            for (let i = 0; i <= rect.width; i += gridSize) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', i);
                line.setAttribute('y1', 0);
                line.setAttribute('x2', i);
                line.setAttribute('y2', rect.height);
                line.setAttribute('stroke', '#007bff');
                line.setAttribute('stroke-width', '1');
                gridOverlay.appendChild(line);
            }
            
            for (let i = 0; i <= rect.height; i += gridSize) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 0);
                line.setAttribute('y1', i);
                line.setAttribute('x2', rect.width);
                line.setAttribute('y2', i);
                line.setAttribute('stroke', '#007bff');
                line.setAttribute('stroke-width', '1');
                gridOverlay.appendChild(line);
            }
        }
        
        function showHighlights() {
            if (!imageData) return;
            highlightTonalRange(200, 255, 'Highlights (200-255)');
        }
        
        function showMidtones() {
            if (!imageData) return;
            highlightTonalRange(85, 200, 'Midtones (85-200)');
        }
        
        function showShadows() {
            if (!imageData) return;
            highlightTonalRange(0, 85, 'Shadows (0-85)');
        }
        
        function highlightTonalRange(min, max, label) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            const newImageData = tempCtx.createImageData(canvas.width, canvas.height);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = Math.round(
                    0.299 * imageData.data[i] +
                    0.587 * imageData.data[i + 1] +
                    0.114 * imageData.data[i + 2]
                );
                
                if (gray >= min && gray <= max) {
                    newImageData.data[i] = 255;     // Red highlight
                    newImageData.data[i + 1] = 0;
                    newImageData.data[i + 2] = 0;
                    newImageData.data[i + 3] = 100; // Semi-transparent
                } else {
                    newImageData.data[i] = imageData.data[i];
                    newImageData.data[i + 1] = imageData.data[i + 1];
                    newImageData.data[i + 2] = imageData.data[i + 2];
                    newImageData.data[i + 3] = 255;
                }
            }
            
            tempCtx.putImageData(newImageData, 0, 0);
            currentImage.src = tempCanvas.toDataURL();
            
            updateTips([{
                content: `<strong>${label}:</strong> These areas are highlighted in red. Focus on these tonal values for your current analysis.`
            }]);
        }
        
        function createOutline() {
            if (!imageData) return;
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // Create outline with improved edge detection
            const newImageData = tempCtx.createImageData(canvas.width, canvas.height);
            
            // Fill with white background first
            for (let i = 0; i < newImageData.data.length; i += 4) {
                newImageData.data[i] = 255;     // R
                newImageData.data[i + 1] = 255; // G
                newImageData.data[i + 2] = 255; // B
                newImageData.data[i + 3] = 255; // A
            }
            
            // First pass: Gaussian blur to reduce noise
            const blurredData = applyGaussianBlur(imageData, canvas.width, canvas.height);
            
            for (let y = 2; y < canvas.height - 2; y++) {
                for (let x = 2; x < canvas.width - 2; x++) {
                    // Get surrounding pixels for enhanced edge detection
                    const getGray = (px, py) => {
                        const idx = (py * canvas.width + px) * 4;
                        return Math.round(0.299 * blurredData[idx] + 0.587 * blurredData[idx + 1] + 0.114 * blurredData[idx + 2]);
                    };
                    
                    // Enhanced Sobel operator with larger kernel for better feature detection
                    const gx = -1 * getGray(x-1, y-1) + 0 * getGray(x, y-1) + 1 * getGray(x+1, y-1) +
                              -2 * getGray(x-1, y) + 0 * getGray(x, y) + 2 * getGray(x+1, y) +
                              -1 * getGray(x-1, y+1) + 0 * getGray(x, y+1) + 1 * getGray(x+1, y+1);
                    
                    const gy = -1 * getGray(x-1, y-1) + -2 * getGray(x, y-1) + -1 * getGray(x+1, y-1) +
                               0 * getGray(x-1, y) + 0 * getGray(x, y) + 0 * getGray(x+1, y) +
                               1 * getGray(x-1, y+1) + 2 * getGray(x, y+1) + 1 * getGray(x+1, y+1);
                    
                    const magnitude = Math.sqrt(gx * gx + gy * gy);
                    
                    // Adaptive threshold based on local contrast
                    const localAvg = (getGray(x-1, y-1) + getGray(x, y-1) + getGray(x+1, y-1) +
                                     getGray(x-1, y) + getGray(x, y) + getGray(x+1, y) +
                                     getGray(x-1, y+1) + getGray(x, y+1) + getGray(x+1, y+1)) / 9;
                    
                    const threshold = Math.max(25, localAvg * 0.15); // Adaptive threshold
                    
                    const idx = (y * canvas.width + x) * 4;
                    
                    if (magnitude > threshold && magnitude < 150) { // Avoid too detailed edges
                        newImageData.data[idx] = 0;     // Black line
                        newImageData.data[idx + 1] = 0;
                        newImageData.data[idx + 2] = 0;
                        newImageData.data[idx + 3] = 255;
                    }
                }
            }
            
            // Clean up isolated pixels and thin lines
            const cleanedData = cleanOutline(newImageData, canvas.width, canvas.height);
            
            tempCtx.putImageData(cleanedData, 0, 0);
            currentImage.src = tempCanvas.toDataURL();
            
            updateTips([{
                content: '<strong>Clean Outline Created:</strong> This shows main features and contours without excessive detail. Use 2H or 3H pencil for these construction lines.'
            }]);
        }
        
        function applyGaussianBlur(imageData, width, height) {
            const blurred = new Uint8ClampedArray(imageData.data);
            const kernel = [1, 2, 1, 2, 4, 2, 1, 2, 1]; // 3x3 Gaussian kernel
            const kernelSum = 16;
            
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) { // RGB channels
                        let sum = 0;
                        let ki = 0;
                        
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                                sum += imageData.data[idx] * kernel[ki];
                                ki++;
                            }
                        }
                        
                        const idx = (y * width + x) * 4 + c;
                        blurred[idx] = sum / kernelSum;
                    }
                }
            }
            
            return blurred;
        }
        
        function cleanOutline(imageData, width, height) {
            const cleaned = new Uint8ClampedArray(imageData.data);
            
            // Remove isolated pixels and strengthen connected lines
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = (y * width + x) * 4;
                    
                    if (imageData.data[idx] === 0) { // If it's a black pixel (edge)
                        // Count neighboring black pixels
                        let neighbors = 0;
                        for (let dy = -1; dy <= 1; dy++) {
                            for (let dx = -1; dx <= 1; dx++) {
                                if (dx === 0 && dy === 0) continue;
                                const nIdx = ((y + dy) * width + (x + dx)) * 4;
                                if (imageData.data[nIdx] === 0) neighbors++;
                            }
                        }
                        
                        // Remove isolated pixels (less than 2 neighbors)
                        if (neighbors < 2) {
                            cleaned[idx] = 255;     // Make white
                            cleaned[idx + 1] = 255;
                            cleaned[idx + 2] = 255;
                        }
                    }
                }
            }
            
            return new ImageData(cleaned, width, height);
        }
        
        function analyzeContrast() {
            if (!imageData) return;
            
            const histogram = new Array(256).fill(0);
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = Math.round(
                    0.299 * imageData.data[i] +
                    0.587 * imageData.data[i + 1] +
                    0.114 * imageData.data[i + 2]
                );
                histogram[gray]++;
            }
            
            const totalPixels = imageData.data.length / 4;
            const shadows = histogram.slice(0, 85).reduce((a, b) => a + b, 0) / totalPixels;
            const midtones = histogram.slice(85, 200).reduce((a, b) => a + b, 0) / totalPixels;
            const highlights = histogram.slice(200, 255).reduce((a, b) => a + b, 0) / totalPixels;
            
            const tips = [];
            
            if (shadows > 0.4) {
                tips.push({
                    content: '<strong>High Shadow Content:</strong> This image has many dark areas. Focus on building up your B pencils (6B-12B) gradually. Use blending stumps for smooth transitions.'
                });
            }
            
            if (highlights > 0.3) {
                tips.push({
                    content: '<strong>High Highlight Content:</strong> Preserve white paper areas. Use kneaded eraser to lift graphite and create bright highlights.'
                });
            }
            
            if (midtones > 0.5) {
                tips.push({
                    content: '<strong>Midtone Heavy:</strong> This image relies on subtle gradations. Use HB-4B pencils with tissue paper blending for smooth transitions.'
                });
            }
            
            const contrast = Math.max(...histogram) / Math.min(...histogram.filter(x => x > 0));
            if (contrast > 100) {
                tips.push({
                    content: '<strong>High Contrast:</strong> Strong light-dark differences. Use full range from 8B to white paper. Build shadows gradually.'
                });
            } else {
                tips.push({
                    content: '<strong>Low Contrast:</strong> Subtle tonal variations. Focus on mid-range pencils (2H-4B). Avoid going too dark too quickly.'
                });
            }
            
            updateTips(tips);
        }
        
        function compareDrawings() {
            if (!currentImage || !currentDrawing) {
                alert('Please upload both a reference image and your drawing first.');
                return;
            }
            
            if (!imageData) {
                setupCanvas();
            }
            
            if (!drawingImageData) {
                setupDrawingCanvas();
            }
            
            // Create comparison overlay on the reference image
            const comparisonCanvas = document.createElement('canvas');
            const compCtx = comparisonCanvas.getContext('2d');
            comparisonCanvas.width = canvas.width;
            comparisonCanvas.height = canvas.height;
            
            // Draw original reference
            compCtx.drawImage(currentImage, 0, 0);
            const refData = compCtx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Resize drawing to match reference
            const drawingCanvas = document.createElement('canvas');
            const drawCtx = drawingCanvas.getContext('2d');
            drawingCanvas.width = canvas.width;
            drawingCanvas.height = canvas.height;
            drawCtx.drawImage(currentDrawing, 0, 0, canvas.width, canvas.height);
            const drawData = drawCtx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Create overlay showing where to improve
            const overlayData = compCtx.createImageData(canvas.width, canvas.height);
            
            let needsShadows = 0;
            let needsHighlights = 0;
            let needsMidtones = 0;
            let needsEraser = 0;
            
            for (let i = 0; i < refData.data.length; i += 4) {
                const refGray = Math.round(0.299 * refData.data[i] + 0.587 * refData.data[i + 1] + 0.114 * refData.data[i + 2]);
                const drawGray = Math.round(0.299 * drawData.data[i] + 0.587 * drawData.data[i + 1] + 0.114 * drawData.data[i + 2]);
                
                const difference = Math.abs(refGray - drawGray);
                
                // Copy original image as base
                overlayData.data[i] = refData.data[i];
                overlayData.data[i + 1] = refData.data[i + 1];
                overlayData.data[i + 2] = refData.data[i + 2];
                overlayData.data[i + 3] = 255;
                
                // Add colored overlays for different improvement areas
                if (difference > 20) {
                    if (refGray < 85 && drawGray > refGray + 25) {
                        // Need darker shadows - RED overlay
                        overlayData.data[i] = Math.min(255, overlayData.data[i] + 100);
                        overlayData.data[i + 1] = Math.max(0, overlayData.data[i + 1] - 50);
                        overlayData.data[i + 2] = Math.max(0, overlayData.data[i + 2] - 50);
                        needsShadows++;
                    } else if (refGray > 200 && drawGray < refGray - 25) {
                        // Need brighter highlights - YELLOW overlay
                        overlayData.data[i] = Math.min(255, overlayData.data[i] + 80);
                        overlayData.data[i + 1] = Math.min(255, overlayData.data[i + 1] + 80);
                        overlayData.data[i + 2] = Math.max(0, overlayData.data[i + 2] - 20);
                        needsHighlights++;
                    } else if (refGray >= 85 && refGray <= 200 && difference > 30) {
                        // Need midtone adjustment - BLUE overlay
                        overlayData.data[i] = Math.max(0, overlayData.data[i] - 30);
                        overlayData.data[i + 1] = Math.max(0, overlayData.data[i + 1] - 30);
                        overlayData.data[i + 2] = Math.min(255, overlayData.data[i + 2] + 60);
                        needsMidtones++;
                    }
                }
                
                // Areas where eraser should be used (drawing too dark in light areas)
                if (refGray > 180 && drawGray < refGray - 40) {
                    // GREEN overlay for eraser areas
                    overlayData.data[i] = Math.max(0, overlayData.data[i] - 50);
                    overlayData.data[i + 1] = Math.min(255, overlayData.data[i + 1] + 100);
                    overlayData.data[i + 2] = Math.max(0, overlayData.data[i + 2] - 50);
                    needsEraser++;
                }
            }
            
            // Apply the overlay to the reference image
            compCtx.putImageData(overlayData, 0, 0);
            currentImage.src = comparisonCanvas.toDataURL();
            
            // Keep the drawing visible for comparison
            // document.getElementById('drawingContainer').style.display = 'none';
            
            // Add legend overlay to show what colors mean
            const legendOverlay = document.createElement('div');
            legendOverlay.id = 'comparisonLegend';
            legendOverlay.style.cssText = `
                position: absolute;
                top: 10px;
                right: 10px;
                background: rgba(255,255,255,0.95);
                padding: 15px;
                border-radius: 10px;
                box-shadow: 0 5px 15px rgba(0,0,0,0.2);
                font-size: 0.9rem;
                z-index: 20;
                max-width: 250px;
            `;
            legendOverlay.innerHTML = `
                <h4 style="margin: 0 0 10px 0; color: #2c3e50;">Color Guide:</h4>
                <div style="margin: 5px 0;"><span style="color: #ff0000; font-weight: bold;">🔴 RED:</span> Add shadows (6B-9B)</div>
                <div style="margin: 5px 0;"><span style="color: #ffaa00; font-weight: bold;">🟡 YELLOW:</span> Brighten highlights (eraser)</div>
                <div style="margin: 5px 0;"><span style="color: #0066ff; font-weight: bold;">🔵 BLUE:</span> Adjust midtones (2B-4B)</div>
                <div style="margin: 5px 0;"><span style="color: #00aa00; font-weight: bold;">🟢 GREEN:</span> Too dark, use eraser</div>
            `;
            
            // Remove existing legend if present
            const existingLegend = document.getElementById('comparisonLegend');
            if (existingLegend) {
                existingLegend.remove();
            }
            
            // Add legend to image container
            document.getElementById('imageContainer').appendChild(legendOverlay);
            
            // Generate detailed tips
            const tips = [];
            const totalPixels = refData.data.length / 4;
            
            tips.push({
                content: '<strong>🔴 RED AREAS - Add Shadows:</strong> Use 6B-9B pencils to darken these areas. Build up gradually with circular motions, then blend with stump.'
            });
            
            tips.push({
                content: '<strong>🟡 YELLOW AREAS - Brighten Highlights:</strong> Use kneaded eraser to lift graphite. Dab gently, don\'t rub. Shape eraser to a point for details.'
            });
            
            tips.push({
                content: '<strong>🔵 BLUE AREAS - Adjust Midtones:</strong> Use 2B-4B pencils for subtle adjustments. Blend with tissue paper for smooth transitions.'
            });
            
            tips.push({
                content: '<strong>🟢 GREEN AREAS - Use Eraser:</strong> These areas are too dark. Use electric eraser for precision or kneaded eraser for gentle lifting.'
            });
            
            if (needsShadows / totalPixels > 0.05) {
                tips.push({
                    content: '<strong>Shadow Priority:</strong> Focus on the red areas first. Use 7B-9B pencils and build darkness gradually. Blend with tortillion.'
                });
            }
            
            if (needsHighlights / totalPixels > 0.05) {
                tips.push({
                    content: '<strong>Highlight Priority:</strong> Work on yellow areas with kneaded eraser. Clean the eraser frequently by kneading it.'
                });
            }
            
            if (needsEraser / totalPixels > 0.03) {
                tips.push({
                    content: '<strong>Eraser Technique:</strong> For green areas, use light dabbing motions with kneaded eraser. Don\'t press hard or rub back and forth.'
                });
            }
            
            // Pencil recommendations based on analysis
            const shadowPercent = (needsShadows / totalPixels) * 100;
            const highlightPercent = (needsHighlights / totalPixels) * 100;
            
            if (shadowPercent > 10) {
                tips.push({
                    content: '<strong>Recommended Pencils:</strong> Focus on 6B, 7B, 8B for shadow work. Use 4B for initial shadow mapping.'
                });
            }
            
            if (highlightPercent > 8) {
                tips.push({
                    content: '<strong>Eraser Tools:</strong> Kneaded eraser (primary), electric eraser (details), white vinyl eraser (clean edges).'
                });
            }
            
            updateTips(tips);
        }
        
        function updateTips(newTips) {
            const tipsContainer = document.getElementById('tipsContainer');
            tipsContainer.innerHTML = '';
            
            newTips.forEach(tip => {
                const tipElement = document.createElement('div');
                tipElement.className = 'tip-item';
                tipElement.innerHTML = tip.content;
                tipsContainer.appendChild(tipElement);
            });
        }
        
        // Initialize with default tips
        window.addEventListener('load', function() {
            const defaultTips = [
                {
                    content: '<strong>Getting Started:</strong> Begin with light strokes using H pencils (2H-4H) for initial sketching and guidelines.'
                },
                {
                    content: '<strong>Building Layers:</strong> Gradually build up darker tones using B pencils, starting with lighter grades (2B, 4B) before moving to darker ones.'
                },
                {
                    content: '<strong>Blending Tools:</strong> Use tissue paper for large areas, blending stumps for medium details, and tortillions for fine work.'
                },
                {
                    content: '<strong>White Areas:</strong> Preserve the white of the paper for your brightest highlights. Plan these areas from the beginning.'
                }
            ];
            updateTips(defaultTips);
        });
        
        // Interactive Tonal Adjustment Functions - now handled by updateTonalValues()
        
        function applyLevelAdjustments(isPreview = false) {
            if (!currentDrawing || !drawingImageData) {
                alert('Please upload your drawing first to adjust levels.');
                return;
            }
            
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = drawingCanvas.width;
            tempCanvas.height = drawingCanvas.height;
            
            const adjustedImageData = tempCtx.createImageData(drawingCanvas.width, drawingCanvas.height);
            
            // Calculate level adjustment parameters
            const inputRange = currentWhitePoint - currentBlackPoint;
            
            for (let i = 0; i < drawingImageData.data.length; i += 4) {
                const r = drawingImageData.data[i];
                const g = drawingImageData.data[i + 1];
                const b = drawingImageData.data[i + 2];
                const a = drawingImageData.data[i + 3];
                
                // Apply levels adjustment to each channel
                let adjustedR = Math.max(0, Math.min(255, ((r - currentBlackPoint) / inputRange) * 255));
                let adjustedG = Math.max(0, Math.min(255, ((g - currentBlackPoint) / inputRange) * 255));
                let adjustedB = Math.max(0, Math.min(255, ((b - currentBlackPoint) / inputRange) * 255));
                
                // Handle edge cases
                if (inputRange <= 0) {
                    adjustedR = r >= currentBlackPoint ? 255 : 0;
                    adjustedG = g >= currentBlackPoint ? 255 : 0;
                    adjustedB = b >= currentBlackPoint ? 255 : 0;
                }
                
                adjustedImageData.data[i] = adjustedR;
                adjustedImageData.data[i + 1] = adjustedG;
                adjustedImageData.data[i + 2] = adjustedB;
                adjustedImageData.data[i + 3] = a;
            }
            
            tempCtx.putImageData(adjustedImageData, 0, 0);
            
            if (isPreview) {
                // Show preview with slight transparency overlay on drawing
                const previewCanvas = document.createElement('canvas');
                const previewCtx = previewCanvas.getContext('2d');
                previewCanvas.width = drawingCanvas.width;
                previewCanvas.height = drawingCanvas.height;
                
                // Draw original drawing
                previewCtx.putImageData(drawingImageData, 0, 0);
                
                // Draw adjusted version with transparency
                previewCtx.globalAlpha = 0.7;
                previewCtx.drawImage(tempCanvas, 0, 0);
                
                document.getElementById('drawingImage').src = previewCanvas.toDataURL();
            } else {
                document.getElementById('drawingImage').src = tempCanvas.toDataURL();
                // Update working drawing data
                drawingImageData = adjustedImageData;
            }
            
            // Update histogram with new drawing data
            if (!isPreview) {
                generateHistogramFromImageData(adjustedImageData);
            }
        }
        
        function resetLevels() {
            const blackSlider = document.getElementById('blackSlider');
            const whiteSlider = document.getElementById('whiteSlider');
            
            // Reset slider positions
            blackSlider.style.left = '0px';
            whiteSlider.style.right = '0px';
            
            currentBlackPoint = 0;
            currentWhitePoint = 255;
            
            document.getElementById('blackValue').textContent = '0';
            document.getElementById('whiteValue').textContent = '255';
            
            if (originalImageData) {
                // Reset to original image
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                tempCtx.putImageData(originalImageData, 0, 0);
                
                currentImage.src = tempCanvas.toDataURL();
                imageData = originalImageData;
                generateHistogramFromImageData(originalImageData);
            }
        }
        
        function applyLevels() {
            if (!originalImageData) return;
            
            applyLevelAdjustments(false);
            
            // Generate tips based on level adjustments
            const tips = [];
            
            if (currentBlackPoint > 0) {
                tips.push({
                    content: `<strong>Darker Blacks:</strong> Black point set to ${currentBlackPoint}. Values below this become pure black. Use 8B-12B pencils for these deepest shadows.`
                });
            }
            
            if (currentWhitePoint < 255) {
                tips.push({
                    content: `<strong>Brighter Whites:</strong> White point set to ${currentWhitePoint}. Values above this become pure white. Preserve these areas as white paper.`
                });
            }
            
            const contrastIncrease = (255 / (currentWhitePoint - currentBlackPoint)) - 1;
            if (contrastIncrease > 0.2) {
                tips.push({
                    content: `<strong>High Contrast Reference:</strong> Contrast increased by ${Math.round(contrastIncrease * 100)}%. Use full pencil range from 9B to white paper. Build shadows gradually.`
                });
            } else if (contrastIncrease < -0.1) {
                tips.push({
                    content: `<strong>Low Contrast Reference:</strong> Contrast reduced. Focus on subtle gradations using HB-4B pencils. Avoid going too dark.`
                });
            }
            
            // Pencil recommendations based on the new tonal range
            const midPoint = (currentBlackPoint + currentWhitePoint) / 2;
            if (midPoint < 100) {
                tips.push({
                    content: '<strong>Dark-Focused Drawing:</strong> This reference emphasizes dark tones. Primary pencils: 4B, 6B, 8B, 10B. Use blending stumps for smooth gradations.'
                });
            } else if (midPoint > 180) {
                tips.push({
                    content: '<strong>Light-Focused Drawing:</strong> This reference emphasizes light tones. Primary pencils: 2H, H, HB, 2B. Use kneaded eraser to create highlights.'
                });
            } else {
                tips.push({
                    content: '<strong>Balanced Tonal Range:</strong> Good contrast balance. Use full range: 4H for construction, HB-4B for main tones, 6B-9B for deep shadows.'
                });
            }
            
            updateTips(tips);
        }
        
        function generateHistogramFromImageData(imgData) {
            const histogram = new Array(256).fill(0);
            
            for (let i = 0; i < imgData.data.length; i += 4) {
                const gray = Math.round(
                    0.299 * imgData.data[i] +
                    0.587 * imgData.data[i + 1] +
                    0.114 * imgData.data[i + 2]
                );
                histogram[gray]++;
            }
            
            drawHistogramBars(histogram);
        }
        
        function getAverageGrayscale() {
            if (!imageData) return 128;
            
            let total = 0;
            let count = 0;
            
            for (let i = 0; i < imageData.data.length; i += 4) {
                const gray = Math.round(
                    0.299 * imageData.data[i] +
                    0.587 * imageData.data[i + 1] +
                    0.114 * imageData.data[i + 2]
                );
                total += gray;
                count++;
            }
            
            return count > 0 ? total / count : 128;
        }
    </script>
</script></body>
</html>
